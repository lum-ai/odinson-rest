<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lum.odinson.rest.responses API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lum.odinson.rest.responses</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from typing import Dict, Iterable, List, Optional, Text, Union
from lum.odinson.doc import Document, Sentence
from pydantic import BaseModel, ConfigDict
from dataclasses import dataclass
import pydantic
import json
import requests


__all__ = [&#34;CorpusInfo&#34;, &#34;OdinsonErrors&#34;, &#34;ScoreDoc&#34;, &#34;Statistic&#34;, &#34;Results&#34;]

# OdinsonMatch = Union[&#34;NamedCapture&#34;, &#34;GraphTraversalMatch&#34;]

mq_desc = pydantic.Field(
    alias=&#34;metadataQuery&#34;,
    description=&#34;A query to filter Documents by their metadata before applying an Odinson pattern. See https://docs.lum.ai/odinson/metadata for details.&#34;,
    default=None,
)

duration_desc = pydantic.Field(description=&#34;The query&#39;s execution time (in seconds)&#34;)


class OdinsonErrors(BaseModel):
    errors: List[str]


class CorpusInfo(BaseModel):
    num_docs: int = pydantic.Field(alias=&#34;numDocs&#34;)
    corpus: str
    # FIXME: make this distinct graph relations
    distinct_dependency_relations: int = pydantic.Field(
        alias=&#34;distinctDependencyRelations&#34;
    )
    token_fields: List[str] = pydantic.Field(alias=&#34;tokenFields&#34;)
    doc_fields: List[str] = pydantic.Field(alias=&#34;docFields&#34;)
    stored_fields: List[str] = pydantic.Field(alias=&#34;storedFields&#34;)
    # model_config = ConfigDict(use_enum_values=True, validate_default=True)


class Statistic(BaseModel):
    #   A term such as a token field or rule name.
    term: str
    #   A grouping term from a second token field (e.g., tag).
    group: str
    #   The number of occurrences of the term (potentially scaled).
    frequency: float


class NamedCapture(BaseModel):
    name: str
    label: str
    captured_match: Union[BaseMatch, EventMatch, NamedCaptureMatch] = pydantic.Field(
        alias=&#34;capturedMatch&#34;
    )


class BaseMatch(BaseModel):
    start: int = pydantic.Field(
        description=&#34;Inclusive token index which denotes the start of this match&#39;s span.&#34;
    )
    end: int = pydantic.Field(
        description=&#34;Exclusive token index which denotes the end of this match&#39;s span.&#34;
    )


class EventMatch(BaseMatch):
    trigger: Union[EventMatch, NamedCaptureMatch, BaseMatch]
    named_captures: List[NamedCapture] = pydantic.Field(alias=&#34;namedCaptures&#34;)


# class NGramMatch(BaseMatch):


class NamedCaptureMatch(BaseMatch):
    named_captures: List[NamedCapture] = pydantic.Field(alias=&#34;namedCaptures&#34;)


class ScoreDoc(BaseModel):
    sentence_id: int = pydantic.Field(
        alias=&#34;sentenceId&#34;, description=&#34;The internal ID for this Odinson Document.&#34;
    )
    score: float = pydantic.Field(description=&#34;The Lucene score for this Document.&#34;)
    document_id: str = pydantic.Field(
        alias=&#34;documentId&#34;,
        description=&#34;The parent document&#39;s ID as provided at index time (uses org.clulab.processors.Document.id)&#34;,
    )
    sentence_index: int = pydantic.Field(
        alias=&#34;sentenceIndex&#34;,
        description=&#34;The index of this sentence in the parent document (0-based).&#34;,
    )
    words: List[str] = pydantic.Field(description=&#34;Tokens for the document (sentence).&#34;)
    matches: List[Union[BaseMatch, EventMatch, NamedCaptureMatch]] = pydantic.Field(
        description=&#34;The list of matching spans for this document.&#34;
    )

    def spans(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Convenience method for getting spans corresponding to matches&#34;&#34;&#34;
        for m in self.matches:
            # FIXME: should this be joined on whitespace?
            yield &#34; &#34;.join(self.words[m.start : m.end])


# class OdinsonSpan(BaseModel):
#     start: int = pydantic.Field(description=&#34;&#34;)
#     end: int = pydantic.Field(description=&#34;&#34;)
# class OdinsonMatch(BaseModel):
#     span: OdinsonSpan = pydantic.Field(description=&#34;&#34;)
#     captures: List[OdinsonSpan] = pydantic.Field(description=&#34;&#34;)


class BaseMention(BaseModel):
    label: str = pydantic.Field(description=&#34;The label for this Mention&#34;)
    sentence_id: int = pydantic.Field(
        alias=&#34;sentenceId&#34;, description=&#34;The internal ID for this Odinson Document.&#34;
    )
    documentId: str = pydantic.Field(
        alias=&#34;documentId&#34;,
        description=&#34;The parent document&#39;s ID as provided at index time.&#34;,
    )
    sentence_index: int = pydantic.Field(
        alias=&#34;sentenceIndex&#34;,
        description=&#34;The positional index (0-based) of the matched sentence in some Odinson Document.&#34;,
    )
    words: List[str] = pydantic.Field(description=&#34;The words of the sentence.&#34;)
    found_by: str = pydantic.Field(
        alias=&#34;foundBy&#34;, description=&#34;The name of the rule that produced this match.&#34;
    )
    match: List[Union[EventMatch, NamedCaptureMatch, BaseMatch]] = pydantic.Field(
        description=&#34;The Mention representing the match.&#34;
    )


class GrammarResults(BaseModel):
    metadata_query: Optional[str] = mq_desc
    duration: float = duration_desc
    allow_trigger_overlaps: bool = pydantic.Field(
        alias=&#34;allowTriggerOverlaps&#34;, description=&#34;&#34;
    )
    mentions: List[BaseMention]

    def model_dump(self, by_alias=True, **kwargs):
        return super().model_dump(by_alias=by_alias, **kwargs)

    def model_dump_json(self, by_alias=True, **kwargs):
        return super().model_dump_json(by_alias=by_alias, **kwargs)

    def dict(self, **kwargs):
        return self.model_dump(**kwargs)

    def json(self, **kwargs):
        return self.model_dump_json(**kwargs)

    # TODO: add convenience methods to get all matched spans


class Results(BaseModel):
    odinson_query: str = pydantic.Field(
        alias=&#34;odinsonQuery&#34;, description=&#34;An Odinson pattern.&#34;
    )
    metadata_query: Optional[str] = mq_desc
    duration: float = duration_desc
    total_hits: int = pydantic.Field(
        alias=&#34;totalHits&#34;,
        description=&#34;The total number of hits (matches) for the query&#34;,
    )
    score_docs: List[ScoreDoc] = pydantic.Field(
        alias=&#34;scoreDocs&#34;, description=&#34;The matches&#34;
    )


#     # The name of the rule which matched this Mention.
#     foundBy: Text
#     matches: List[Match]
#     # match: Interval
#     #

#     #       &#34;duration&#34;             -&gt; duration,
#     #       &#34;allowTriggerOverlaps&#34; -&gt; allowTriggerOverlaps,
#     #       &#34;mentions&#34;             -&gt; mentionsJson

#     # // format: off
#     # &#34;sentenceId&#34;    -&gt; mention.luceneDocId,
#     # // &#34;score&#34;         -&gt; odinsonScoreDoc.score,
#     # &#34;label&#34;         -&gt; mention.label,
#     # &#34;documentId&#34;    -&gt; getOdinsonDocId(mention.luceneDocId),
#     # &#34;sentenceIndex&#34; -&gt; getSentenceIndex(mention.luceneDocId),
#     # &#34;words&#34;         -&gt; JsArray(tokens.map(JsString)),
#     # &#34;foundBy&#34;       -&gt; mention.foundBy,
#     # &#34;match&#34;         -&gt; Json.arr(mkJsonForMatch(mention.odinsonMatch))


# class Interval(BaseModel):
#     # Inclusive token index which denotes the start of this match&#39;s span.
#     start: int
#     # Exclusive token index which denotes the end of this match&#39;s span.
#     end: int


# class Match(BaseModel):
#     span: Interval
#     # Named captures for this match.
#     # NamedCapture(name: String, label: Option[String], capturedMatch: OdinsonMatch)
#     captures: List[NamedCapture]

#     # def start: Int
#     # def end: Int
#     # def namedCaptures: Array[NamedCapture]

#     # /** The length of the match */
#     # def length: Int = end - start

#     # /** The interval of token indices that form this mention. */
#     # def tokenInterval: Interval = Interval.open(start, end)


# # val arguments: Map[String, Array[Mention]] = Map.empty


# class BaseMention(BaseModel):
#     odinsonMatch: OdinsonMatch
#     label: Text
#     luceneDocId: int
#     foundBy: Text
#     arguments: Dict[Text, List[BaseMention]]

#     def to_mention(self, api: OdinsonBaseAPI) -&gt; Mention:
#         &#34;&#34;&#34;
#         Converts to lum.odinson.Mention
#         &#34;&#34;&#34;
#         convert = lambda role, mns: Argument(
#             role=role, mentions=[bm.to_mention(api) for bm in mns]
#         )

#         return Mention(
#             _api=api,
#             label=self.label,
#             luceneDocId=self.luceneDocId,
#             foundBy=self.foundBy,
#             arguments=[convert(role, mns) for (role, mns) in self.arguments.items()],
#         )


# @dataclass
# class Argument:
#     role: Text
#     mentions: List[Mention]


# @dataclass
# class Mention:
#     _api: OdinsonBaseAPI
#     label: Text
#     luceneDocId: int
#     foundBy: Text
#     arguments: List[Argument]
#     # todo __get__ for args

#     @property
#     def sentence(self) -&gt; Sentence:
#         pass


# # class NamedCapture(BaseModel):
# #     name: Text
# #     label: Text
# #     match: List[NamedCapture]


# # class GraphTraversalMatch(BaseModel):
# #     srcMatch: OdinsonMatch
# #     dstMatch: OdinsonMatch</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lum.odinson.rest.responses.CorpusInfo"><code class="flex name class">
<span>class <span class="ident">CorpusInfo</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A base model class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_config</code></strong></dt>
<dd>Configuration settings for the model.</dd>
<dt><strong><code>model_fields</code></strong></dt>
<dd>Metadata about the fields defined on the model.
This replaces <code>Model.__fields__</code> from Pydantic V1.</dd>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly specified during validation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CorpusInfo(BaseModel):
    num_docs: int = pydantic.Field(alias=&#34;numDocs&#34;)
    corpus: str
    # FIXME: make this distinct graph relations
    distinct_dependency_relations: int = pydantic.Field(
        alias=&#34;distinctDependencyRelations&#34;
    )
    token_fields: List[str] = pydantic.Field(alias=&#34;tokenFields&#34;)
    doc_fields: List[str] = pydantic.Field(alias=&#34;docFields&#34;)
    stored_fields: List[str] = pydantic.Field(alias=&#34;storedFields&#34;)
    # model_config = ConfigDict(use_enum_values=True, validate_default=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.rest.responses.CorpusInfo.corpus"><code class="name">var <span class="ident">corpus</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.distinct_dependency_relations"><code class="name">var <span class="ident">distinct_dependency_relations</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.doc_fields"><code class="name">var <span class="ident">doc_fields</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.num_docs"><code class="name">var <span class="ident">num_docs</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.stored_fields"><code class="name">var <span class="ident">stored_fields</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.CorpusInfo.token_fields"><code class="name">var <span class="ident">token_fields</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="lum.odinson.rest.responses.OdinsonErrors"><code class="flex name class">
<span>class <span class="ident">OdinsonErrors</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A base model class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_config</code></strong></dt>
<dd>Configuration settings for the model.</dd>
<dt><strong><code>model_fields</code></strong></dt>
<dd>Metadata about the fields defined on the model.
This replaces <code>Model.__fields__</code> from Pydantic V1.</dd>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly specified during validation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OdinsonErrors(BaseModel):
    errors: List[str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.rest.responses.OdinsonErrors.errors"><code class="name">var <span class="ident">errors</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.OdinsonErrors.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.OdinsonErrors.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="lum.odinson.rest.responses.Results"><code class="flex name class">
<span>class <span class="ident">Results</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A base model class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_config</code></strong></dt>
<dd>Configuration settings for the model.</dd>
<dt><strong><code>model_fields</code></strong></dt>
<dd>Metadata about the fields defined on the model.
This replaces <code>Model.__fields__</code> from Pydantic V1.</dd>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly specified during validation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Results(BaseModel):
    odinson_query: str = pydantic.Field(
        alias=&#34;odinsonQuery&#34;, description=&#34;An Odinson pattern.&#34;
    )
    metadata_query: Optional[str] = mq_desc
    duration: float = duration_desc
    total_hits: int = pydantic.Field(
        alias=&#34;totalHits&#34;,
        description=&#34;The total number of hits (matches) for the query&#34;,
    )
    score_docs: List[ScoreDoc] = pydantic.Field(
        alias=&#34;scoreDocs&#34;, description=&#34;The matches&#34;
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.rest.responses.Results.duration"><code class="name">var <span class="ident">duration</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.metadata_query"><code class="name">var <span class="ident">metadata_query</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.odinson_query"><code class="name">var <span class="ident">odinson_query</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.score_docs"><code class="name">var <span class="ident">score_docs</span> : List[<a title="lum.odinson.rest.responses.ScoreDoc" href="#lum.odinson.rest.responses.ScoreDoc">ScoreDoc</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Results.total_hits"><code class="name">var <span class="ident">total_hits</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc"><code class="flex name class">
<span>class <span class="ident">ScoreDoc</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A base model class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_config</code></strong></dt>
<dd>Configuration settings for the model.</dd>
<dt><strong><code>model_fields</code></strong></dt>
<dd>Metadata about the fields defined on the model.
This replaces <code>Model.__fields__</code> from Pydantic V1.</dd>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly specified during validation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScoreDoc(BaseModel):
    sentence_id: int = pydantic.Field(
        alias=&#34;sentenceId&#34;, description=&#34;The internal ID for this Odinson Document.&#34;
    )
    score: float = pydantic.Field(description=&#34;The Lucene score for this Document.&#34;)
    document_id: str = pydantic.Field(
        alias=&#34;documentId&#34;,
        description=&#34;The parent document&#39;s ID as provided at index time (uses org.clulab.processors.Document.id)&#34;,
    )
    sentence_index: int = pydantic.Field(
        alias=&#34;sentenceIndex&#34;,
        description=&#34;The index of this sentence in the parent document (0-based).&#34;,
    )
    words: List[str] = pydantic.Field(description=&#34;Tokens for the document (sentence).&#34;)
    matches: List[Union[BaseMatch, EventMatch, NamedCaptureMatch]] = pydantic.Field(
        description=&#34;The list of matching spans for this document.&#34;
    )

    def spans(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Convenience method for getting spans corresponding to matches&#34;&#34;&#34;
        for m in self.matches:
            # FIXME: should this be joined on whitespace?
            yield &#34; &#34;.join(self.words[m.start : m.end])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.rest.responses.ScoreDoc.document_id"><code class="name">var <span class="ident">document_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.matches"><code class="name">var <span class="ident">matches</span> : List[Union[lum.odinson.rest.responses.BaseMatch, lum.odinson.rest.responses.EventMatch, lum.odinson.rest.responses.NamedCaptureMatch]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.score"><code class="name">var <span class="ident">score</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.sentence_id"><code class="name">var <span class="ident">sentence_id</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.sentence_index"><code class="name">var <span class="ident">sentence_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.ScoreDoc.words"><code class="name">var <span class="ident">words</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lum.odinson.rest.responses.ScoreDoc.spans"><code class="name flex">
<span>def <span class="ident">spans</span></span>(<span>self) ‑> Iterable[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method for getting spans corresponding to matches</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spans(self) -&gt; Iterable[str]:
    &#34;&#34;&#34;Convenience method for getting spans corresponding to matches&#34;&#34;&#34;
    for m in self.matches:
        # FIXME: should this be joined on whitespace?
        yield &#34; &#34;.join(self.words[m.start : m.end])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lum.odinson.rest.responses.Statistic"><code class="flex name class">
<span>class <span class="ident">Statistic</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A base model class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_config</code></strong></dt>
<dd>Configuration settings for the model.</dd>
<dt><strong><code>model_fields</code></strong></dt>
<dd>Metadata about the fields defined on the model.
This replaces <code>Model.__fields__</code> from Pydantic V1.</dd>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly specified during validation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Statistic(BaseModel):
    #   A term such as a token field or rule name.
    term: str
    #   A grouping term from a second token field (e.g., tag).
    group: str
    #   The number of occurrences of the term (potentially scaled).
    frequency: float</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.rest.responses.Statistic.frequency"><code class="name">var <span class="ident">frequency</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Statistic.group"><code class="name">var <span class="ident">group</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Statistic.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Statistic.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.rest.responses.Statistic.term"><code class="name">var <span class="ident">term</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lum.odinson.rest" href="index.html">lum.odinson.rest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lum.odinson.rest.responses.CorpusInfo" href="#lum.odinson.rest.responses.CorpusInfo">CorpusInfo</a></code></h4>
<ul class="">
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.corpus" href="#lum.odinson.rest.responses.CorpusInfo.corpus">corpus</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.distinct_dependency_relations" href="#lum.odinson.rest.responses.CorpusInfo.distinct_dependency_relations">distinct_dependency_relations</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.doc_fields" href="#lum.odinson.rest.responses.CorpusInfo.doc_fields">doc_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.model_config" href="#lum.odinson.rest.responses.CorpusInfo.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.model_fields" href="#lum.odinson.rest.responses.CorpusInfo.model_fields">model_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.num_docs" href="#lum.odinson.rest.responses.CorpusInfo.num_docs">num_docs</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.stored_fields" href="#lum.odinson.rest.responses.CorpusInfo.stored_fields">stored_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.CorpusInfo.token_fields" href="#lum.odinson.rest.responses.CorpusInfo.token_fields">token_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.odinson.rest.responses.OdinsonErrors" href="#lum.odinson.rest.responses.OdinsonErrors">OdinsonErrors</a></code></h4>
<ul class="">
<li><code><a title="lum.odinson.rest.responses.OdinsonErrors.errors" href="#lum.odinson.rest.responses.OdinsonErrors.errors">errors</a></code></li>
<li><code><a title="lum.odinson.rest.responses.OdinsonErrors.model_config" href="#lum.odinson.rest.responses.OdinsonErrors.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.rest.responses.OdinsonErrors.model_fields" href="#lum.odinson.rest.responses.OdinsonErrors.model_fields">model_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.odinson.rest.responses.Results" href="#lum.odinson.rest.responses.Results">Results</a></code></h4>
<ul class="two-column">
<li><code><a title="lum.odinson.rest.responses.Results.duration" href="#lum.odinson.rest.responses.Results.duration">duration</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.metadata_query" href="#lum.odinson.rest.responses.Results.metadata_query">metadata_query</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.model_config" href="#lum.odinson.rest.responses.Results.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.model_fields" href="#lum.odinson.rest.responses.Results.model_fields">model_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.odinson_query" href="#lum.odinson.rest.responses.Results.odinson_query">odinson_query</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.score_docs" href="#lum.odinson.rest.responses.Results.score_docs">score_docs</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Results.total_hits" href="#lum.odinson.rest.responses.Results.total_hits">total_hits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.odinson.rest.responses.ScoreDoc" href="#lum.odinson.rest.responses.ScoreDoc">ScoreDoc</a></code></h4>
<ul class="two-column">
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.document_id" href="#lum.odinson.rest.responses.ScoreDoc.document_id">document_id</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.matches" href="#lum.odinson.rest.responses.ScoreDoc.matches">matches</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.model_config" href="#lum.odinson.rest.responses.ScoreDoc.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.model_fields" href="#lum.odinson.rest.responses.ScoreDoc.model_fields">model_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.score" href="#lum.odinson.rest.responses.ScoreDoc.score">score</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.sentence_id" href="#lum.odinson.rest.responses.ScoreDoc.sentence_id">sentence_id</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.sentence_index" href="#lum.odinson.rest.responses.ScoreDoc.sentence_index">sentence_index</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.spans" href="#lum.odinson.rest.responses.ScoreDoc.spans">spans</a></code></li>
<li><code><a title="lum.odinson.rest.responses.ScoreDoc.words" href="#lum.odinson.rest.responses.ScoreDoc.words">words</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.odinson.rest.responses.Statistic" href="#lum.odinson.rest.responses.Statistic">Statistic</a></code></h4>
<ul class="">
<li><code><a title="lum.odinson.rest.responses.Statistic.frequency" href="#lum.odinson.rest.responses.Statistic.frequency">frequency</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Statistic.group" href="#lum.odinson.rest.responses.Statistic.group">group</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Statistic.model_config" href="#lum.odinson.rest.responses.Statistic.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Statistic.model_fields" href="#lum.odinson.rest.responses.Statistic.model_fields">model_fields</a></code></li>
<li><code><a title="lum.odinson.rest.responses.Statistic.term" href="#lum.odinson.rest.responses.Statistic.term">term</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>