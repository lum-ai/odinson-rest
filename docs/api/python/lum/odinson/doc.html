<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lum.odinson.doc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lum.odinson.doc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
import dateutil
from lum.odinson.typing import Tokens
from enum import Enum
from typing import Any, List, Literal, Sequence, Text, Tuple, Type, Union
import abc
from pydantic import BaseModel, ConfigDict
import pydantic
import gzip
import json

__all__ = [&#34;Document&#34;, &#34;AnyField&#34;]


class Fields(Text, Enum):
    # $type      ai.lum.odinson.*
    TOKENS_FIELD = &#34;ai.lum.odinson.TokensField&#34;
    GRAPH_FIELD = &#34;ai.lum.odinson.GraphField&#34;
    STRING_FIELD = &#34;ai.lum.odinson.StringField&#34;
    DATE_FIELD = &#34;ai.lum.odinson.DateField&#34;
    NUMBER_FIELD = &#34;ai.lum.odinson.NumberField&#34;
    NESTED_FIELD = &#34;ai.lum.odinson.NestedField&#34;

    def __repr__(self) -&gt; str:
        return str.__repr__(self.value)


class Field(BaseModel):
    name: Text
    type: Fields = pydantic.Field(alias=&#34;$type&#34;, default=&#34;ai.lum.odinson.Field&#34;)
    model_config = ConfigDict(use_enum_values=True, validate_default=True)


class TokensField(Field):
    tokens: Tokens
    type: Literal[Fields.TOKENS_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.TOKENS_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        return hash((self.name, self.type, tuple(self.tokens)))


class GraphField(Field):
    edges: List[Tuple[int, int, Text]]
    roots: Sequence[int]
    type: Literal[Fields.GRAPH_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.GRAPH_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        roots = tuple(self.roots)
        edges = tuple(
            sorted(self.edges, key=lambda triple: (triple[0], triple[1], triple[2]))
        )
        return hash((self.name, self.type, roots, edges))


class StringField(Field):
    string: Text
    type: Literal[Fields.STRING_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.STRING_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        return hash((self.name, self.type, self.string))


class DateField(Field):
    date: Text
    type: Literal[Fields.DATE_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.DATE_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        return hash((self.name, self.type, self.date))


class NumberField(Field):
    value: float
    type: Literal[Fields.NUMBER_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.NUMBER_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        return hash((self.name, self.type, self.value))


class NestedField(Field):
    fields: List[Type[Field]]
    type: Literal[Fields.NESTED_FIELD] = pydantic.Field(
        alias=&#34;$type&#34;, default=Fields.NESTED_FIELD.value, frozen=True
    )

    def __hash__(self) -&gt; int:
        return hash((self.name, self.type, tuple(self.fields)))


AnyField = Union[
    TokensField, GraphField, StringField, DateField, NumberField, NestedField
]


class Metadata:
    &#34;&#34;&#34;Utility methods for contructing metadata&#34;&#34;&#34;

    @staticmethod
    def from_dict(d) -&gt; List[AnyField]:
        fields = []
        for fname, v in d.items():
            if isinstance(v, str):
                # try parsing as date
                try:
                    _ = dateutil.parser.parse(v)
                    fields.append(DateField(name=fname, date=v))
                except:
                    fields.append(StringField(name=fname, string=v))
            elif isinstance(v, float) or isinstance(v, int):
                fields.append(NumberField(name=fname, value=float(v)))
            elif isinstance(v, list):
                # if all elems are str -&gt; TokensField
                pass
            elif isinstance(v, dict):
                # if contains &#34;edges&#34; and &#34;roots&#34; -&gt; GraphField
                pass


class Token:
    &#34;&#34;&#34;Convenience class to represent a single token
    and its attributes&#34;&#34;&#34;

    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            self.__dict__[k] = v

    def __len__(self):
        return len(self.raw)

    def __str__(self):
        return self.raw

    def __hash__(self):
        return hash(tuple(frozenset(sorted(self.__dict__.items()))))


class Sentence(BaseModel):
    numTokens: int
    # FIXME: figure out how to just use List[Type[Field]]
    fields: List[AnyField]
    model_config = ConfigDict(extra=&#34;allow&#34;)

    def model_post_init(self, ctx) -&gt; None:
        &#34;&#34;&#34;Easy access to fields&#34;&#34;&#34;
        tokens = [dict([]) for _ in range(self.numTokens)]
        graph = None
        for f in self.fields:
            key = f.name
            # token attributes
            if isinstance(f, TokensField):
                # populate tokens
                for i, label in enumerate(f.tokens):
                    tokens[i][key] = label
                self.__dict__[key] = f.tokens
            # syntactic dependencies, semantic roles, etc.
            elif isinstance(f, GraphField):
                graph = f
        # create tokens
        self.__dict__[&#34;tokens&#34;] = [Token(**d) for d in tokens]

        # TODO: create graph
        # if graph is not None:
        #   edges = []
        #   self.__dict__[&#34;edges&#34;] =
        #   key = &#34;edges&#34;

    def __getitem__(self, index: int) -&gt; Token:
        return self.tokens[index]

    def __hash__(self):
        num_tokens = [self.numTokens]
        fields = [hash(f) for f in self.fields]
        components = num_tokens + fields
        return hash(tuple(components))

    def model_dump(self, by_alias=True, **kwargs):
        return super().model_dump(by_alias=by_alias, **kwargs)

    def model_dump_json(self, by_alias=True, **kwargs):
        return super().model_dump_json(by_alias=by_alias, **kwargs)

    def dict(self, **kwargs):
        return self.model_dump(**kwargs)

    def json(self, **kwargs):
        return self.model_dump_json(**kwargs)


class Document(BaseModel):
    &#34;&#34;&#34;ai.lum.odinson.Document&#34;&#34;&#34;

    id: Text
    metadata: List[AnyField]
    sentences: List[Sentence]

    def __hash__(self):
        metadata = [0] if len(self.metadata) == 0 else [hash(f) for f in self.metadata]
        sentences = [hash(s) for s in self.sentences]
        components = [hash(self.id)] + metadata + sentences
        return hash(tuple(components))

    def model_post_init(self, ctx) -&gt; None:
        tokens = []
        attributes = dict()
        for s in self.sentences:
            # append tokens
            tokens.append(s.tokens)
            for f in s.fields:
                key = f.name
                # token attributes
                if isinstance(f, TokensField):
                    values = attributes.get(key, [])
                    # nested list
                    values.append(s.__dict__[key])
                    attributes[key] = values
        for k, v in attributes.items():
            self.__dict__[k] = v

        self.__dict__[&#34;tokens&#34;] = [s.tokens for s in self.sentences]

    def metadata_by_name(self, name: str) -&gt; List[AnyField]:
        return [m for m in self.metadata if m.name == name]

    def metadata_by_type(self, mtype: AnyField) -&gt; List[AnyField]:
        return [m for m in self.metadata if m.type == mtype]

    def model_dump(self, by_alias=True, **kwargs):
        return super().model_dump(by_alias=by_alias, **kwargs)

    def model_dump_json(self, by_alias=True, **kwargs):
        return super().model_dump_json(by_alias=by_alias, **kwargs)

    def dict(self, **kwargs):
        return self.model_dump(**kwargs)

    def json(self, **kwargs):
        return self.model_dump_json(**kwargs)

    @staticmethod
    def from_file(fp: Text) -&gt; Document:
        if fp.lower().endswith(&#34;.gz&#34;):
            with gzip.open(fp, &#34;rb&#34;) as f:
                return Document(**json.loads(f.read()))
        else:
            with open(fp, &#34;r&#34;) as f:
                return Document(**json.loads(f.read()))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lum.odinson.doc.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>ai.lum.odinson.Document</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p>
<p>Uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Document(BaseModel):
    &#34;&#34;&#34;ai.lum.odinson.Document&#34;&#34;&#34;

    id: Text
    metadata: List[AnyField]
    sentences: List[Sentence]

    def __hash__(self):
        metadata = [0] if len(self.metadata) == 0 else [hash(f) for f in self.metadata]
        sentences = [hash(s) for s in self.sentences]
        components = [hash(self.id)] + metadata + sentences
        return hash(tuple(components))

    def model_post_init(self, ctx) -&gt; None:
        tokens = []
        attributes = dict()
        for s in self.sentences:
            # append tokens
            tokens.append(s.tokens)
            for f in s.fields:
                key = f.name
                # token attributes
                if isinstance(f, TokensField):
                    values = attributes.get(key, [])
                    # nested list
                    values.append(s.__dict__[key])
                    attributes[key] = values
        for k, v in attributes.items():
            self.__dict__[k] = v

        self.__dict__[&#34;tokens&#34;] = [s.tokens for s in self.sentences]

    def metadata_by_name(self, name: str) -&gt; List[AnyField]:
        return [m for m in self.metadata if m.name == name]

    def metadata_by_type(self, mtype: AnyField) -&gt; List[AnyField]:
        return [m for m in self.metadata if m.type == mtype]

    def model_dump(self, by_alias=True, **kwargs):
        return super().model_dump(by_alias=by_alias, **kwargs)

    def model_dump_json(self, by_alias=True, **kwargs):
        return super().model_dump_json(by_alias=by_alias, **kwargs)

    def dict(self, **kwargs):
        return self.model_dump(**kwargs)

    def json(self, **kwargs):
        return self.model_dump_json(**kwargs)

    @staticmethod
    def from_file(fp: Text) -&gt; Document:
        if fp.lower().endswith(&#34;.gz&#34;):
            with gzip.open(fp, &#34;rb&#34;) as f:
                return Document(**json.loads(f.read()))
        else:
            with open(fp, &#34;r&#34;) as f:
                return Document(**json.loads(f.read()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.odinson.doc.Document.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.doc.Document.metadata"><code class="name">var <span class="ident">metadata</span> : List[Union[lum.odinson.doc.TokensField, lum.odinson.doc.GraphField, lum.odinson.doc.StringField, lum.odinson.doc.DateField, lum.odinson.doc.NumberField, lum.odinson.doc.NestedField]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.doc.Document.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.doc.Document.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.odinson.doc.Document.sentences"><code class="name">var <span class="ident">sentences</span> : List[lum.odinson.doc.Sentence]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lum.odinson.doc.Document.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>fp: Text) ‑> <a title="lum.odinson.doc.Document" href="#lum.odinson.doc.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_file(fp: Text) -&gt; Document:
    if fp.lower().endswith(&#34;.gz&#34;):
        with gzip.open(fp, &#34;rb&#34;) as f:
            return Document(**json.loads(f.read()))
    else:
        with open(fp, &#34;r&#34;) as f:
            return Document(**json.loads(f.read()))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lum.odinson.doc.Document.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict(self, **kwargs):
    return self.model_dump(**kwargs)</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self, **kwargs):
    return self.model_dump_json(**kwargs)</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.metadata_by_name"><code class="name flex">
<span>def <span class="ident">metadata_by_name</span></span>(<span>self, name: str) ‑> List[Union[lum.odinson.doc.TokensField, lum.odinson.doc.GraphField, lum.odinson.doc.StringField, lum.odinson.doc.DateField, lum.odinson.doc.NumberField, lum.odinson.doc.NestedField]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_by_name(self, name: str) -&gt; List[AnyField]:
    return [m for m in self.metadata if m.name == name]</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.metadata_by_type"><code class="name flex">
<span>def <span class="ident">metadata_by_type</span></span>(<span>self, mtype: AnyField) ‑> List[Union[lum.odinson.doc.TokensField, lum.odinson.doc.GraphField, lum.odinson.doc.StringField, lum.odinson.doc.DateField, lum.odinson.doc.NumberField, lum.odinson.doc.NestedField]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_by_type(self, mtype: AnyField) -&gt; List[AnyField]:
    return [m for m in self.metadata if m.type == mtype]</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.model_dump"><code class="name flex">
<span>def <span class="ident">model_dump</span></span>(<span>self, by_alias=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump">https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump</a></p>
<p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>The mode in which <code>to_python</code> should run.
If mode is 'json', the dictionary will only contain JSON serializable types.
If mode is 'python', the dictionary may contain any Python objects.</dd>
<dt><strong><code>include</code></strong></dt>
<dd>A list of fields to include in the output.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>A list of fields to exclude from the output.</dd>
<dt><strong><code>by_alias</code></strong></dt>
<dd>Whether to use the field's alias in the dictionary key if defined.</dd>
<dt><strong><code>exclude_unset</code></strong></dt>
<dd>Whether to exclude fields that are unset or None from the output.</dd>
<dt><strong><code>exclude_defaults</code></strong></dt>
<dd>Whether to exclude fields that are set to their default value from the output.</dd>
<dt><strong><code>exclude_none</code></strong></dt>
<dd>Whether to exclude fields that have a value of <code>None</code> from the output.</dd>
<dt><strong><code>round_trip</code></strong></dt>
<dd>Whether to enable serialization and deserialization round-trip support.</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>Whether to log warnings when invalid fields are encountered.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary representation of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_dump(self, by_alias=True, **kwargs):
    return super().model_dump(by_alias=by_alias, **kwargs)</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.model_dump_json"><code class="name flex">
<span>def <span class="ident">model_dump_json</span></span>(<span>self, by_alias=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump_json">https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump_json</a></p>
<p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong></dt>
<dd>Indentation to use in the JSON output. If None is passed, the output will be compact.</dd>
<dt><strong><code>include</code></strong></dt>
<dd>Field(s) to include in the JSON output. Can take either a string or set of strings.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>Field(s) to exclude from the JSON output. Can take either a string or set of strings.</dd>
<dt><strong><code>by_alias</code></strong></dt>
<dd>Whether to serialize using field aliases.</dd>
<dt><strong><code>exclude_unset</code></strong></dt>
<dd>Whether to exclude fields that have not been explicitly set.</dd>
<dt><strong><code>exclude_defaults</code></strong></dt>
<dd>Whether to exclude fields that have the default value.</dd>
<dt><strong><code>exclude_none</code></strong></dt>
<dd>Whether to exclude fields that have a value of <code>None</code>.</dd>
<dt><strong><code>round_trip</code></strong></dt>
<dd>Whether to use serialization/deserialization between JSON and class instance.</dd>
<dt><strong><code>warnings</code></strong></dt>
<dd>Whether to show any warnings that occurred during serialization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON string representation of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_dump_json(self, by_alias=True, **kwargs):
    return super().model_dump_json(by_alias=by_alias, **kwargs)</code></pre>
</details>
</dd>
<dt id="lum.odinson.doc.Document.model_post_init"><code class="name flex">
<span>def <span class="ident">model_post_init</span></span>(<span>self, ctx) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.
This is useful if you want to do some validation that requires the entire model to be initialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_post_init(self, ctx) -&gt; None:
    tokens = []
    attributes = dict()
    for s in self.sentences:
        # append tokens
        tokens.append(s.tokens)
        for f in s.fields:
            key = f.name
            # token attributes
            if isinstance(f, TokensField):
                values = attributes.get(key, [])
                # nested list
                values.append(s.__dict__[key])
                attributes[key] = values
    for k, v in attributes.items():
        self.__dict__[k] = v

    self.__dict__[&#34;tokens&#34;] = [s.tokens for s in self.sentences]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lum.odinson" href="index.html">lum.odinson</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lum.odinson.doc.Document" href="#lum.odinson.doc.Document">Document</a></code></h4>
<ul class="two-column">
<li><code><a title="lum.odinson.doc.Document.dict" href="#lum.odinson.doc.Document.dict">dict</a></code></li>
<li><code><a title="lum.odinson.doc.Document.from_file" href="#lum.odinson.doc.Document.from_file">from_file</a></code></li>
<li><code><a title="lum.odinson.doc.Document.id" href="#lum.odinson.doc.Document.id">id</a></code></li>
<li><code><a title="lum.odinson.doc.Document.json" href="#lum.odinson.doc.Document.json">json</a></code></li>
<li><code><a title="lum.odinson.doc.Document.metadata" href="#lum.odinson.doc.Document.metadata">metadata</a></code></li>
<li><code><a title="lum.odinson.doc.Document.metadata_by_name" href="#lum.odinson.doc.Document.metadata_by_name">metadata_by_name</a></code></li>
<li><code><a title="lum.odinson.doc.Document.metadata_by_type" href="#lum.odinson.doc.Document.metadata_by_type">metadata_by_type</a></code></li>
<li><code><a title="lum.odinson.doc.Document.model_config" href="#lum.odinson.doc.Document.model_config">model_config</a></code></li>
<li><code><a title="lum.odinson.doc.Document.model_dump" href="#lum.odinson.doc.Document.model_dump">model_dump</a></code></li>
<li><code><a title="lum.odinson.doc.Document.model_dump_json" href="#lum.odinson.doc.Document.model_dump_json">model_dump_json</a></code></li>
<li><code><a title="lum.odinson.doc.Document.model_fields" href="#lum.odinson.doc.Document.model_fields">model_fields</a></code></li>
<li><code><a title="lum.odinson.doc.Document.model_post_init" href="#lum.odinson.doc.Document.model_post_init">model_post_init</a></code></li>
<li><code><a title="lum.odinson.doc.Document.sentences" href="#lum.odinson.doc.Document.sentences">sentences</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>